<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CodegenCS</name>
    </assembly>
    <members>
        <member name="T:CodegenCS.CodegenContext">
            <inheritdoc/>
        </member>
        <member name="P:CodegenCS.CodegenContext.Errors">
            <inheritdoc />
        </member>
        <member name="F:CodegenCS.CodegenContext._outputFiles">
            <summary>
            Output files indexed by their relative paths
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenContext.OutputFiles">
            <inheritdoc />
        </member>
        <member name="P:CodegenCS.CodegenContext.DefaultOutputFile">
            <inheritdoc />
        </member>
        <member name="M:CodegenCS.CodegenContext.#ctor">
            <inheritdocs />
        </member>
        <member name="P:CodegenCS.CodegenContext.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CodegenCS.CodegenContext.SaveFiles(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CodegenCS.CodegenContext.SaveFiles">
            <summary>
            Saves all files in the current directory. <br />
            According to the RelativePath of each file they may be saved in different folders
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenContext.GetUnknownFiles(System.String)">
            <summary>
            After calling SaveFiles() you may decide to clean-up the Outputfolder (assuming it only has code-generation output). <br />
            This returns all files which are in the Outputfolder (and subfolders) and which were NOT generated as part of this Context. <br />
            Beware that files which are deleted using File.Delete do NOT get moved to Recycle bin.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenContext.ResolveDependency``1(System.Object[])">
            <summary>
            Creates an instance of a dependency <typeparamref name="T"/> (usually a Template) and (if constructor needs) it injects ICodegenContext or ICodegenTextWriter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CodegenCS.CodegenContext.ResolveDependency(System.Type,System.Object[])">
            <summary>
            Creates an instance of a dependency <paramref name="type"/> (usually a Template) and (if constructor needs) it injects ICodegenContext or ICodegenTextWriter
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenContext`2">
            <summary>
            CodegenContext keeps track of multiple files which can be saved at once in the output folder, <br />
            while also tracking the type for each output file
            </summary>
            <typeparam name="O">Class of OutputFiles. Should inherit from CodegenOutputFile</typeparam>
            <typeparam name="FT">Enum which defines the Types that each file can have</typeparam>
        </member>
        <member name="P:CodegenCS.CodegenContext`2._defaultType">
            <summary>
            Default Type for new OutputFiles, if it's a fixed value.
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenContext`2._getDefaultType">
            <summary>
            Default Type for new OutputFiles, if it's a Func
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenContext`2.#ctor(`0,System.Func{System.String,`0,CodegenCS.ICodegenContext,`1})">
            <summary>
            Creates new in-memory context.
            </summary>
            <param name="defaultType">Default Type for files (if file type is not defined)</param>
            <param name="outputFileFactory">Factory to build output files</param>
        </member>
        <member name="M:CodegenCS.CodegenContext`2.#ctor(System.Func{System.String,`0},System.Func{System.String,`0,CodegenCS.ICodegenContext,`1})">
            <summary>
            Creates new in-memory context.
            </summary>
            <param name="getDefaultType">Default Type for files (if file type is not defined)</param>
            <param name="outputFileFactory">Factory to build output files</param>
        </member>
        <member name="P:CodegenCS.CodegenContext`2.Item(System.String)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="P:CodegenCS.CodegenContext`2.Item(System.String,`0)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
            <param name="relativePath"></param>
            <param name="fileType"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenContext`1.#ctor(`0)">
            <summary>
            Creates new in-memory context.
            </summary>
            <param name="defaultType">Default Type for files (if file type is not defined)</param>
        </member>
        <member name="M:CodegenCS.CodegenContext`1.#ctor(System.Func{System.String,`0})">
            <summary>
            Creates new in-memory context.
            </summary>
            <param name="getDefaultType">Default Type for files (if file type is not defined)</param>
        </member>
        <member name="T:CodegenCS.CodegenOutputFile">
            <summary>
            CodegenTextWriter with added properties that describe Outputfile location (RelativePath)
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenOutputFile.RelativePath">
            <summary>
            Relative path of the output file (relative to the outputFolder).
            For the <see cref="P:CodegenCS.ICodegenContext.DefaultOutputFile"/> it will be initially empty
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenOutputFile.#ctor(System.String)">
            <summary>
            Creates a new OutputFile, with a relative path
            </summary>
            <param name="relativePath"></param>
        </member>
        <member name="T:CodegenCS.CodegenOutputFile`1">
            <summary>
            CodegenTextWriter with added properties that describe Outputfile location (RelativePath) <br />
            and type of output (regarding .NET Project - if file is Compiled, NotCompiled, etc)
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenOutputFile`1.FileType">
            <summary>
            Type of file
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenOutputFile`1.#ctor(System.String,`0)">
            <summary>
            Creates a new OutputFile, with a relative path
            </summary>
            <param name="relativePath"></param>
            <param name="fileType"></param>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter">
            <summary>
            This text writer has some features to help code-generation tools: <br />
            - Will keep track of "Indent Levels", and will write whitespace-indents accordingly to the current level. <br />
              It's possible to explicitly increase/decrease indent level <br />
              It's possible to change the IndentString <br />
              It's possible to increase level using "using (writer.WithIndent()) {...}". <br />
              There's a shortcut to start C-style blocks: using (writer.WithCStyleBlock($"public class {myClass}")). Will automatically start "{" and close with "}" <br /><br />
              
            - Allows to execute "inline actions", which mean that writer will save the current cursor position, and will run the action which may write a string. <br />
              If the string has multiple lines, all lines starting from the second will "preserve" the same indent (cursor position) that was there when we started writing the first line. <br />
              This means that it's possible to embed blocks "inline", while preserving the correct indent where the block should start. <br />
               This allow us to use any kind of "template include" functions without having to manually control indentation. <br />
               In case ICodegenTextWriter uses these inline actions to write string-interpolation-based templates, but we could also use Razor, Dotliquid, Scriban, or any other template engine. <br /><br />
            
            - Allows to write complex templates using pure C# language and interpolated strings. <br />
              Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments.  <br />
              Since we also control indentation (and preserve indentation even when we run "inline actions" in the middle of the template), this works like a charm. <br /><br />
              
            - For convenience, all multi-line string blocks will have the first empty line removed and Left Padding removed. <br />
              This means that you can write the multi-line strings with any number of padding spaces, and yet those spaces will be ignored - so you can align the  <br />
              generated code with the outer control code. <br /><br />
              
            Summary of the method chain: <br />
            - _innerWriter is the underlying TextWriter. It's used by: <br />
                - InnerWriteRaw is the only method which writes to _innerWriter. It's used by: <br />
                    - InnerIndentCurrentLine (which only writes whitespace indentation) <br />
                    - WriteLine (which only writes a raw "NewLine") <br />
                    - InnerWrite (which splits multiline blocks and writes NewLines and strings individually by using InnerWriteRaw. <br />
                      InnerWrite is where all Indentation is controlled and automatically managed. It can write multiline texts and correct "respect" parent indentation. <br />
                      InnerWrite is used by: <br />
                        - IndentedBlockScope class (which write _beforeBlock and _afterBlock - these usually are one-line, but if multiple lines they need to respect parent indentation) <br />
                        - All public Write* methods <br />
                        - InnerWriteFormattable (which writes interpolated strings which can mix strings, variables, and also action delegates which will be lazy-evaluated) <br />
            AdjustMultilineString will manipulate multi-line blocks (trim first line if it's empty, and will removes the left padding of the block by calculating the minimum number of spaces which happens in every line)<br />
            All public methods should call AdjustMultilineString to adjust the block before calling other methods.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._innerWriter">
            <summary>
            CodegenTextWriter will always write to an inner TextWriter. <br />
            This TextWriter can be explicitly defined; <br />
            Can be StreamWriter writing to a file; <br />
            Or can be an in-memory StringWriter.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._lineBreaksRegex">
            <summary>
            Identify all types of line-breaks
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._normalizeLineEndings">
            <summary>
            If true, will normalize line breaks by replacing different styles (\n, \r\n, \r, etc) by _innerWriter.NewLine
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.MultilineBehavior">
            <summary>
            How multi-line text blocks are adjusted
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.MultilineBehaviorType">
            <summary>
            How multi-line text blocks are adjusted
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.None">
            <summary>
            Do not remove manipulate multi-line text blocks (write them as they are). <br />
            You'll have to handle mixed indentation levels for text blocks and outer control code.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPadding">
            <summary>
            Will remove the left padding of multi-line text blocks, by "untabbing" the block until some row "touches" the margin.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPaddingAndRemoveFirstEmptyLine">
            <summary>
            Will remove left padding and will remove the first empty line
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.CurlyBracesStyleType">
            <summary>
            How Curly-Braces are written
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.CurlyBracesStyleType.C">
            <summary>
            K&amp;R style (Kernighan &amp; Ritchie Style). <br />
            Used in most C/C++/C# code: <br /> 
            - There's a new line before opening curly braces. <br />
            - There's a new line after closing curly braces.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.CurlyBracesStyleType.Java">
            <summary>
            Java style: <br />
            - No new line before opening curly braces <br />
            - There's a new line after closing curly braces. 
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.CurlyBracesStyle">
            <summary>
            How Curly-Braces are written
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._encoding">
            <summary>
            Encoding
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._currentLine">
            <summary>
            This keeps tracks of what was written to the current line.<br /> 
            This includes whitespace which was explicitly or implicitally written, but DOES NOT COUNT indent-strings that were automatically generated by this text writer (InnerIndentCurrentLine). <br />
            In other words, it's the current line written after automatic indentation
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.IO.TextWriter)">
            <summary>
            New CodegenTextWriter writing to another (inner) textWriter
            </summary>
            <param name="textWriter">Inner TextWriter to write to</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor">
            <summary>
            New CodegenTextWriter writing to an in-memory StringWriter (using UTF-8 encoding). <br />
            You may choose when to save this file.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.String)">
            <summary>
            New CodegenTextWriter writing directly to a file. <br />
            Default encoding is UTF-8.
            </summary>
            <param name="filePath">Target file</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.String,System.Text.Encoding)">
            <summary>
            New CodegenTextWriter writing directly to a file. 
            </summary>
            <param name="filePath">Target file</param>
            <param name="encoding">Encoding</param>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.NewLine">
            <summary>
            The default line terminator string is a carriage return followed by a line feed ("\r\n"). <br />
            You may override it (Unix uses "\n", Apple use "\r"). <br />
            PS: Null will be replaced by the default terminator (use empty if appropriate).
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.Encoding">
            <summary>
            The character encoding in which the output is written.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Close">
            <summary>
            Closes the current writer and releases any system resources associated with the writer.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Flush">
            <summary>
            Clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Dispose(System.Boolean)">
            <summary>
            Clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._levelIndent">
            <summary>
            Each level of indentation may have it's own indentation marker <br />
            e.g. one block may have "    " (4 spaces), while other may have "-- " (SQL line-comment), etc.
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.IndentLevel">
            <summary>
            Current IndentLevel
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.IndentString">
            <summary>
            Default Indentation marker is 4 strings. <br />
            You can change to whatever you want
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerIncreaseIndent">
            <summary>
            Increases indentation level, so that the next text lines are all indented with an increased level. 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.IncreaseIndent">
            <summary>
            Explicitly Increases indentation level, <br />
            so that the next text lines are all indented with an increased level. <br />
            If you're using helpers like WithIndent, WithCurlyBraces or WithPythonBlock you don't need to manually control indent level.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerDecreaseIndent">
            <summary>
            Decreases indentation level, so that the next text lines are all indented with a decreased level. 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.DecreaseIndent">
            <summary>
            Explicitly Decreases indentation level, <br />
            so that the next text lines are all indented with an decreased level. <br />
            If you're using helpers like WithIndent, WithCurlyBraces or WithPythonBlock you don't need to manually control indent level.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.EnsureEmptyLine">
            <summary>
            Ensures that current cursor position is not dirty (cursor position is zero). If dirty, writes line break
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.EnsureLineBreakBeforeNextWrite">
            <summary>
            Ensures that if current line is dirty then nothing more can be written to this line, so the next write will enforce (render automatically) a line break.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent">
            <summary>
            Explicitly opens a new indented Block (prefer using implicit indentation when possible). Will automatically handle increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent. <br />
            This method will automatically fix "dirty lines" (lines which do not end in a line break).
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent(System.String,System.String)">
            <summary>
            Explicitly opens a new indented Block (prefer using implicit indentation when possible). Will automatically handle increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent. <br />
            This method will automatically fix "dirty lines" (lines which do not end in a line break).
            </summary>
            <param name="beforeBlock">Optional - you can specify something to be written BEFORE the indented block starts (before the automatic line break, yet with outer indentation)</param>
            <param name="afterBlock">Optional - you can specify something to be written immediately AFTER the block finishes (back with outer indentation)
            If you're closing with a curly brace you'll probably want to add a line-break after that curly brace.
            </param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent(System.String,System.String,System.Action)">
            <summary>
            Explicitly opens a new indented indented Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the block <br />
            Will automatically handle increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify something to be written BEFORE the indented block starts (before the automatic line break, yet with outer indentation)</param>
            <param name="afterBlock">Optional - you can specify something to be written immediately AFTER the block finishes (back with outer indentation)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent(System.String,System.String,System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Explicitly opens a new indented indented Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the block <br />
            Will automatically handle increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify something to be written BEFORE the indented block starts (before the automatic line break, yet with outer indentation)</param>
            <param name="afterBlock">Optional - you can specify something to be written immediately AFTER the block finishes (back with outer indentation)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerIndentCurrentLine">
            <summary>
            This writes the whole indentation before the current line writes any text <br />
            E.g. Usually for IndentLevel 1 this would be 4 spaces, for IndentLevel 2 it would be 8 spaces. <br />
            Depending on settings it can be based on tabs, or different number of spaces, etc.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._controlFlowSymbols">
            <summary>
            Each level of indentation may have it's own indentation marker <br />
            e.g. one block may have "    " (4 spaces), while other may have "-- " (SQL line-comment), etc.
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.IsControlBlockActive">
            <summary>
            Returns true if there's no IF/ELSE block open, or if the current block is "active" (should NOT be discarded according to the IF clauses in the stack)
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces(System.String,CodegenCS.CodegenTextWriter.CurlyBracesStyleType)">
            <summary>
            Explicitly opens a new indented Curly-Braces Block (prefer using implicit indentation when possible). Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="curlyBracesStyle">How Curly-Braces are written. If not defined will use current CurleBracesStyleType property (default is C-Style, which starts the curly braces in its own line) </param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces(System.String)">
            <summary>
            Explicitly opens a new indented Curly-Braces Block (prefer using implicit indentation when possible). Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces">
            <summary>
            Explicitly opens a new indented Curly-Braces Block (prefer using implicit indentation when possible). Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces(System.String,System.Action)">
            <summary>
            Explicitly opens a new indented Curly-Braces Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the curly-braces block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces(System.String,System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Explicitly opens a new indented Curly-Braces Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the curly-braces block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithPythonBlock(System.String)">
            <summary>
            Explicitly opens a new indented Python-Braces Block (prefer using implicit indentation when possible). Will automatically handle linebreaks, and increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithPythonBlock(System.String,System.Action)">
            <summary>
            Explicitly opens a new indented Python-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts.</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the indented block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithPythonBlock(System.String,System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Explicitly opens a new indented Python-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts.</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the indented block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock(System.String)">
            <summary>
            Explicitly opens a new indented C-Style Block (prefer using implicit indentation when possible). Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the block starts (before curly braces)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock(System.String,System.Action)">
            <summary>
            Explicitly opens a new indented C-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock(System.String,System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Explicitly opens a new indented C-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithJavaBlock(System.String)">
            <summary>
            Explicitly opens a new indented Java-Style Block (prefer using implicit indentation when possible). Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the block starts (before curly braces)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithJavaBlock(System.String,System.Action)">
            <summary>
            Explicitly opens a new indented Java-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithJavaBlock(System.String,System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Explicitly opens a new indented Java-style Block (prefer using implicit indentation when possible). Action delegate (lambda) should be used to write contents "inside" the indented block <br />
            Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="innerBlockAction">Action delegate (lambda) should be used to write contents "inside" the curly-braces block.</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerWriteRaw(System.String)">
            <summary>
            This is the lowest-level Write method. All writing methods end up here.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerWrite(System.String)">
            <summary>
            This is the "heart" of the indentation-control. Basically, this split any multi-line string, and writes line by line.  <br />
            Before writing each new line we write the indent block, <br />
            which could for example be 8 spaces (4 spaces in first indent level and 4 spaces for second indent level), <br />
            or 2 tabs (one for each indent level), or any combination.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerInlineAction(System.Action)">
            <summary>
            Invokes an inline action (which may reference current ICodegenTextWriter and write to it) <br />
            If the action writes multiple lines and current line has some manually-written whitespace, <br />
            this method will "save" current cursor position and the subsequent lines (after the first) will "preserve" the cursor position by prepending this manual indentation. <br />
            In other words, this will capture manually-written whitespace indentation (those whice are not yet tracked by the automatic indentation), and will consider this manual indentation and preserve it in subsequent lines.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ExecuteInlineAction(System.Action{CodegenCS.ICodegenTextWriter})">
            <summary>
            Invokes an inline action (which may reference current ICodegenTextWriter and write to it) <br />
            If the action writes multiple lines and current line has some manually-written whitespace, <br />
            this method will "save" current cursor position and the subsequent lines (after the first) will "preserve" the cursor position by prepending this manual indentation. <br />
            In other words, this will capture manually-written whitespace indentation (those whice are not yet tracked by the automatic indentation), and will consider this manual indentation and preserve it in subsequent lines.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerWriteFormattable(System.String,System.Object[])">
            <summary>
            All public Write methods pass through this method <br />.
            This method splits an interpolated string and writes block by block, doing lazy-evaluation of arguments <br />
            In the interpolated strings we can mix literals and variables (like any interpolated string), but also Func/Action delegates, which are evaluated only during the rendering. <br />
            One advantage of passing delegates (Func&lt;FormattableString&gt;, Func&lt;string&gt;, Action, Action&lt;ICodegenTextWriter&gt; ) as {arguments} <br />
            is that we do NOT evaluate those arguments BEFORE the outer string is being written - they are only evaluated when needed <br />
            so we can capture the cursor position in current line, and preserve it if the arguments render multi-line strings
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.InnerWriteFormattableArgument(System.Object,System.String)">
            <summary>
            Interpolated strings used in ICodegenTextWriter may contain as arguments (expressions) not only variables/expressions but also Action delegates. <br />
            This method prints those arguments.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.FormattableString)">
            <summary>
            Writes to the stream/writer an interpolated string (which arguments can mix strings, variables, and also action delegates which will be lazy-evaluated)
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.FormattableString)">
            <summary>
            Writes to the stream/writer an interpolated string (which arguments can mix strings, variables, and also action delegates which will be lazy-evaluated) and a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(CodegenCS.RawString,System.Object[])">
            <summary>
            Writes to the stream/writer a formatted string (like string.Format, where arguments are replaced in the string)
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(CodegenCS.RawString,System.Object[])">
            <summary>
            Writes to the stream/writer a formatted string (like string.Format, where arguments are replaced in the string) and a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.Object)">
            <summary>
            Writes object to the stream/writer
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.Object)">
            <summary>
            Writes object and new line to the stream/writer
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine">
            <summary>
            Writes to the stream/writer a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(CodegenCS.RawString)">
            <summary>
            Writes to the stream/writer a plain string 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(CodegenCS.RawString)">
            <summary>
            Writes to the stream/writer a plain string and a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.Func{CodegenCS.RawString})">
            <summary>
            Writes to the stream/writer the result of Lazy evaluation of a Func&lt;string&gt;
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.Func{CodegenCS.RawString})">
            <summary>
            Writes to the stream/writer the result of Lazy evaluation of a Func&lt;string&gt; and a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.Func{System.FormattableString})">
            <summary>
            Writes to the stream/writer the result of Lazy evaluation of a Func&lt;FormattableString&gt;
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.Func{System.FormattableString})">
            <summary>
            Writes to the stream/writer the result of Lazy evaluation of a Func&lt;FormattableString&gt; and a new line
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.Char[])">
            <summary>
            Writes buffer to the stream/writer a plain string 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Writes buffer to the stream/writer a plain string 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.Char[])">
            <summary>
            Writes buffer to the stream/writer a plain string 
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteLine(System.Char[],System.Int32,System.Int32)">
            <summary>
            Writes buffer to the stream/writer
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.SaveToFile(System.String,System.Boolean)">
            <summary>
            Writes current content (assuming it was in-memory writer) to a new file. If the target file already exists, it is overwritten. <br />
            </summary>
            <param name="path">Absolute path</param>
            <param name="createFolder">If this is true (default is true) and target folder does not exist, it will be created</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.GetContents">
            <summary>
            Get full contents of current Writer
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.AdjustMultilineString(System.String)">
            <summary>
            Given a text block (multiple lines), this removes the left padding of the block, by calculating the minimum number of spaces which happens in EVERY line.
            Then, other methods writes the lines one by one, which in case will respect the current indent of the writer.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ResolveDependency``1(System.Object[])">
            <summary>
            Creates an instance of a dependency <typeparamref name="T"/> (usually a Template) and (if constructor needs) it injects ICodegenContext or ICodegenTextWriter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ResolveDependency(System.Type,System.Object[])">
            <summary>
            Creates an instance of a dependency<paramref name= "type" /> (usually a Template) and(if constructor needs) it injects ICodegenContext or ICodegenTextWriter
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.IndentedBlockScope">
            <summary>
            An IndentedBlockScope defines the scope of an indented block of text <br />
            When created it increases the indent level of the associated CodegenTextWriter, <br />
            and when disposed it decreases the indent level (so it's important to use it in a "using" statements to automatically dispose scope at end). <br /><br />
            
            Most programming languages use indented blocks to control scope: <br />
            - Python-like languages define scope solely based on the indentation of the text blocks. <br />
            - C/Java-like language define scope based on curly braces but use indented blocks for readibility. <br /><br />
            
            For convenience/conciseness this helper allows to define some text to be written BEFORE the indented block starts, <br />
            and some text to be written AFTER the indented block ends. <br /><br />
            
            For convenience this helper will automatically add line breaks if it find "dirty" lines (lines which have some text but don't end in a line break): <br />
            - The indented block will always start on an empty (non-dirty) line (adds linebreak if previous write didn't end in line break) <br />
            - The indented block will always ensure that next write starts on an empty (non-dirty) line (next write after block end will add a linebreak if previous write didn't end in line break) <br />
            - The text that is written before the block (if provided) will always start on an empty (non-dirty) line (adds linebreak if previous write didn't end in line break) <br />
            - The text that is written after the block (if provided) will always end "into" an empty (non-dirty) line (automatically adds final linebreak if not defined in text)
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.IndentedBlockScope.#ctor(CodegenCS.CodegenTextWriter)">
            <summary>
            An IndentedBlockScope defines the scope of an indented block of text
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.IndentedBlockScope.#ctor(CodegenCS.CodegenTextWriter,System.String,System.String)">
            <summary>
            An IndentedBlockScope defines the scope of an indented block of text
            </summary>
            <param name="writer"></param>
            <param name="beforeBlock">What to write immediately before the indented block starts (before the line break, yet with outer indentation level)</param>
            <param name="afterBlock">What to write immediately after the indented block ends (right after the line break, back with outer indentation level)</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.IndentedBlockScope.Dispose">
            <summary>
            When we dispose, we just restore back the old level of the writer
            </summary>
        </member>
        <member name="T:CodegenCS.ControlFlow.IControlFlowSymbol">
            <summary>
            Any control-flow symbol, like IF / ELSE / ENDIF
            </summary>
        </member>
        <member name="T:CodegenCS.ControlFlow.UnbalancedIfsException">
            <summary>
            When there is an unbalanced number of IF/ELSE/ENDIF. Each IF should have a matching ENDIF, and may have an optional ELSE.
            </summary>
        </member>
        <member name="M:CodegenCS.ControlFlow.UnbalancedIfsException.#ctor">
            <inheritdoc/>
        </member>
        <member name="T:CodegenCS.DependencyContainer">
            <summary>
            Dependency Injection Container which can create types (in our case mostly for Templates) 
            and will automatically resolve (inject) ICodegenContext, CodegenOutputFile, and any other registered dependency.
            </summary>
            
        </member>
        <member name="M:CodegenCS.DependencyContainer.RegisterTransient``2">
            <summary>
            Transient means that a new instance is always created
            </summary>
        </member>
        <member name="M:CodegenCS.DependencyContainer.RegisterTransient``1">
            <summary>
            Transient means that a new instance is always created
            </summary>
        </member>
        <member name="M:CodegenCS.DependencyContainer.RegisterTransient``1(System.Func{``0})">
            <summary>
            Transient objects are always different (new instance is always created)
            </summary>
        </member>
        <member name="M:CodegenCS.DependencyContainer.RegisterSingleton``1(``0)">
            <summary>
            Singleton registration for cases when the instance is already created.
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:CodegenCS.DependencyContainer.RegisterSingleton``1(System.Func{``0})">
            <summary>
            Singleton registration for cases when the instance is not yet created or might need other dependencies.
            The factory is wrapped under a Lazy wrapper so it's possible that the service might not even be created if not required.
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="factory"></param>
        </member>
        <member name="T:CodegenCS.DotNet.BuildActionType">
            <summary>
            All files in a Visual Studio project have a build action. The build action controls what happens to the file when the project is compiled. <br />
            The most common action (like for compiling CS files) is Compile. <br />
            This enum only have common type for code generation. See complete list here: https://docs.microsoft.com/en-us/visualstudio/ide/build-actions?view=vs-2019 <br />
            Or here https://stackoverflow.com/a/145769/3606250
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.BuildActionType.None">
            <summary>
            The file isn't part of the build in any way. This value can be used for documentation files such as "ReadMe" files, for example.
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.BuildActionType.Compile">
            <summary>
            The file is passed to the compiler as a source file.
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.BuildActionType.Content">
            <summary>
            A file marked as Content can be retrieved as a stream by calling Application.GetContentStream.  <br />
            For ASP.NET projects, these files are included as part of the site when it's deployed.
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.BuildActionType.EmbeddedResource">
            <summary>
            The file is passed to the compiler as a resource to be embedded in the assembly.  <br />
            You can call System.Reflection.Assembly.GetManifestResourceStream to read the file from the assembly.
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.BuildActionType.NonProjectItem">
            <summary>
            Special enum which means that the file will NOT be added to the CSPROJ <br />
            For .NET Framework projects (not NET Core) this means that the file will NOT be added to the CSPROJ (even if you use MSBuildProjectEditor) <br />
            For .NET Core projects (where all files are automatically considered as compilable except if explicitly removed) this means that the file will be explicitly REMOVED from the CSPROJ.
            </summary>
        </member>
        <member name="T:CodegenCS.DotNet.DotNetCodegenContext">
            <summary>
            DotNetCodegenContext is like CodegenContext (keeps track of multiple files which can be saved at once in the output folder) <br />
            but additionally it also tracks the BuildActionType for each output file, <br />
            making it easier to save those files in the csproj (when applicable) with MSBuildProjectEditor class <br />
            If you're generating only .CS files for a SDK-Style project (those created with Visual Studio 2017 or newer) you can just use the regular CodegenContext,
            since you don't need to add the output cs files to the csproj file.
            </summary>
        </member>
        <member name="M:CodegenCS.DotNet.DotNetCodegenContext.#ctor">
            <inheritdocs />
        </member>
        <member name="M:CodegenCS.DotNet.DotNetCodegenContext.GetFileType(System.String)">
            <summary>
            Will infer BuildActionType from the file extension
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.DotNet.DotNetCodegenContext.AddToProject(System.String,System.String)">
            <summary>
            Ensures that all files generated under this Context are added to the MSBuild project (csproj, vbproj) <br />
            This is mostly for old non-SDK-Style projects (before Visual Studio 2017), <br />
            since the new SDK-Style automatically builds all CS files which are under the csproj folder (they don't need to be explicitly referenced in csproj).
            </summary>
            <param name="csproj">Full path of csproj/vbproj</param>
            <param name="outputFolder">Base folder where your output files were saved. Same as used in SaveFiles()</param>
        </member>
        <member name="T:CodegenCS.DotNet.MSBuildProjectEditor">
            <summary>
            Allows to load a MSBuild project (csproj, vbproj, etc), to automatically include files. <br />
            Accepts projects both in new SDK-Style format and in the old non-SDK-Style format, <br />
            although the new SDK-Style automatically builds all CS files even if they are not referenced <br />
            (actually it's the opposite, in new SDK-Style the EXCLUDED files should be described).
            </summary>
        </member>
        <member name="M:CodegenCS.DotNet.MSBuildProjectEditor.#ctor(System.String)">
            <summary>
            New in-memory editor.
            </summary>
            <param name="projectFilePath"></param>
        </member>
        <member name="M:CodegenCS.DotNet.MSBuildProjectEditor.AddItem(System.String,CodegenCS.DotNet.BuildActionType,System.String)">
            <summary>
            Adds a single item, optionally dependent of a parent item (DependentUpon). 
            </summary>
        </member>
        <member name="M:CodegenCS.DotNet.MSBuildProjectEditor.RemoveUnusedDependentItems(System.String)">
            <summary>
            Given an item in the project, will remove all items which depend on this parent item, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.DotNet.MSBuildProjectEditor.RemoveUnusedItems(System.String)">
            <summary>
            Given a folder in the project, will remove all items which are under this folder, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.DotNet.MSBuildProjectEditor.Save">
            <summary>
            Saves all changes into the csproj/vbproj
            </summary>
        </member>
        <member name="T:CodegenCS.DotNet.ProjectType">
            <summary>
            There are basically 2 types of .NET Projects: SDK-Style, Non-SDK-Style (or Legacy) <br />
            Those types do not have a special extension - they can be csproj, vbproj, etc. <br />
            The Non-SDK style was the most popular until Visual Studio 2015, and is more complex because it describes all files. <br />
            The SDK style started with MSBuild 15 (Visual Studio 2017), and is more modern and more concise since it doesn't require to describe all files in the project. <br />
            The SDK style also replaces the old XPROJ/Project.JSON format which was introduced with NETCORE but is barely used now. 
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.ProjectType.SDKStyle">
            <summary>
            MSBuild SDK-Style is the new .NET Standard - these project files auto-include files with certain extensions automatically from the project folder. <br />
            This change has been introduced with MSBuld 15 (Visual Studio 2017 /NetStandard /.NET Core) and makes it much easier to maintain project files. <br />
            </summary>
        </member>
        <member name="F:CodegenCS.DotNet.ProjectType.NonSDKStyle">
            <summary>
            MSBuild Non-SDK-Style is the traditional project format, now considered legacy. It's more verbose than the new SDK-Style.
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenContext">
            <summary>
            ICodegenContext keeps track of multiple output files and define how those outputs are saved.
            </summary>
        </member>
        <member name="P:CodegenCS.ICodegenContext.Errors">
            <summary>
            If your template finds any error you can just append the errors here in this list <br />
            SaveFiles() does not work if there is any error.
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenContext.SaveFiles(System.String)">
            <summary>
            Saves all files in the outputFolder. <br />
            According to the RelativePath of each file they may be saved in different folders
            </summary>
            <param name="outputFolder">Can be absolute or relative</param>
        </member>
        <member name="P:CodegenCS.ICodegenContext.OutputFilesPaths">
            <summary>
            Paths of the Output files (as defined during creation using <see cref="P:CodegenCS.ICodegenContext.Item(System.String)"/> indexer)
            </summary>
        </member>
        <member name="P:CodegenCS.ICodegenContext.OutputFiles">
            <summary>
            Output files (created using <see cref="P:CodegenCS.ICodegenContext.Item(System.String)"/> indexer)
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenContext.OnOutputFileRenamed(System.String,System.String)">
            <summary>
            When a <see cref="T:CodegenCS.ICodegenOutputFile"/> is renamed it should notify the <see cref="T:CodegenCS.ICodegenContext"/> by calling this method.
            </summary>
            <returns>True if context could successfuly find and rename the file</returns>
        </member>
        <member name="P:CodegenCS.ICodegenContext.Item(System.String)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
        </member>
        <member name="P:CodegenCS.ICodegenContext.DefaultOutputFile">
            <summary>
            Default Output file if we write a single-file template (<see cref="T:CodegenCS.ICodegenTemplate"/> or <see cref="T:CodegenCS.ICodegenStringTemplate"/>) to a Context (that could potentially manage multiple outputs)
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenContext.LoadTemplate``1(System.Object[])">
            <summary>
            Loads any template by the Type.
            After loading don't forget to call Render() extensions (<see cref="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.ICodegenContext})"/>)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dependencies">Optional dependencies can be used and will be automatically injected if template constructor requires it</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.ICodegenContext.RenderTemplate(CodegenCS.ICodegenTemplate)">
            <summary>
            Renders to the <see cref="P:CodegenCS.ICodegenContext.DefaultOutputFile"/> a <see cref="T:CodegenCS.ICodegenTemplate"/> template that do not need any model.
            If you need a template that takes a model please use <see cref="M:CodegenCS.ICodegenContext.LoadTemplate``1(System.Object[])"/> method.
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenContext.RenderTemplate(CodegenCS.ICodegenStringTemplate)">
            <summary>
            Renders to the <see cref="P:CodegenCS.ICodegenContext.DefaultOutputFile"/> a <see cref="T:CodegenCS.ICodegenStringTemplate"/> template that do not need any model.
            If you need a template that takes a model please use <see cref="M:CodegenCS.ICodegenContext.LoadTemplate``1(System.Object[])"/> method.
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenContext.RenderTemplate(CodegenCS.ICodegenMultifileTemplate)">
            <summary>
            Renders a <see cref="T:CodegenCS.ICodegenMultifileTemplate"/> template that do not need any model. 
            Template can render to multiple output files.
            If you need a template that takes a model please use <see cref="M:CodegenCS.ICodegenContext.LoadTemplate``1(System.Object[])"/> method.
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenContext`1">
            <summary>
            IMultiplefiletypeCodegenContext extends <see cref="T:CodegenCS.ICodegenContext"/> by allowing each outputfile
            to be classified with a file type (enum <typeparamref name="FT"/> contains all possible types).
            Based on the different file types the context may take different actions for saving each file
            </summary>
        </member>
        <member name="T:CodegenCS.ICustomWriterCodegenContext`1">
            <summary>
            ICodegenContext<typeparamref name="O"/> extends <see cref="T:CodegenCS.ICodegenContext"/> by allowing the the use of a custom implementation of OutputFile (custom writer of type <typeparamref name="O"/>)
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenContext`2">
            <summary>
            Most generic interface of ICodegenContext, combining both <see cref="T:CodegenCS.ICustomWriterCodegenContext`1"/> and <see cref="T:CodegenCS.ICodegenContext`1"/>:
            - Keeps track of multiple output files and define how those outputs are saved.
            - Uses a custom implementation of OutputFile (custom writer of type <typeparamref name="O"/>)
            - Generates output files of different file types (<typeparamref name="FT"/> is an enum of the possible types)
            - The different types are used for something (e.g. the different types may use different actions for being added to the project file)
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenTextWriter.LoadTemplate``1(System.Object[])">
            <summary>
            Loads any template by the Type.
            After loading don't forget to call Render() extensions (<see cref="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.ICodegenContext})"/>)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dependencies">Optional dependencies can be used and will be automatically injected if template constructor requires it</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.ICodegenTextWriter.RenderTemplate(CodegenCS.ICodegenTemplate)">
            <summary>
            Renders a <see cref="T:CodegenCS.ICodegenTemplate"/> template that do not need any model.
            If you need a template that takes a model please use <see cref="M:CodegenCS.ICodegenTextWriter.LoadTemplate``1(System.Object[])"/> method.
            </summary>
        </member>
        <member name="M:CodegenCS.ICodegenTextWriter.RenderTemplate(CodegenCS.ICodegenStringTemplate)">
            <summary>
            Renders a <see cref="T:CodegenCS.ICodegenStringTemplate"/> template that do not need any model.
            If you need a template that takes a model please use <see cref="M:CodegenCS.ICodegenTextWriter.LoadTemplate``1(System.Object[])"/> method.
            </summary>
        </member>
        <member name="T:CodegenCS.InputModels.IInputModel">
            <summary>
            Input Models provide information to be used in Templates (generators)
            </summary>
        </member>
        <member name="T:CodegenCS.InputModels.IJsonInputModel">
            <summary>
            JSON-based Input Models provide information to be used in Templates (generators)
            </summary>
        </member>
        <member name="P:CodegenCS.InputModels.IJsonInputModel.Schema">
            <summary>
            Json Schema which uniquely identifies this model.
            Should follow https://json-schema.org/ specs.
            Can be a url, can have a version in the url.
            E.g. "http://codegencs.com/schemas/dbschema/2021-07/dbschema.json"
            </summary>
        </member>
        <member name="T:CodegenCS.InputModels.JsonInputModelParser">
            <summary>
            Parser for JsonInputModels
            </summary>
        </member>
        <member name="M:CodegenCS.InputModels.JsonInputModelParser.ValidateSchemaAsync(System.String,System.String)">
            <summary>
            Returns if a given model is valid according to Json Schema
            </summary>
        </member>
        <member name="T:CodegenCS.InlineIEnumerable`1">
            <summary>
            This is just a wrapper to pass IEnumerable{T} with custom <see cref="T:CodegenCS.RenderEnumerableOptions"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:CodegenCS.IEnumerableExtensions">
            <summary>
            One of the major features of ICodegenTextWriter is that it accepts FormattableStrings (interpolated strings) everywhere and it can render a large number of object types that you can just interpolate. <br />
            IEnumerables of FormattableString, Func{FormattableString}, string, or Func{string} can be embedded directly and they will be automatically rendered by ICodegenTextWriter which handles not only writing
            the different items (while handling indentation as usual) but also how the items should be separated from each other.
            The Render() extensions below allow users to specify custom rendering options to adjust how items should be separated, how last line should be handled, etc.
            </summary>
        </member>
        <member name="M:CodegenCS.IEnumerableExtensions.Render``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Renders the items using the default configuration from <see cref="P:CodegenCS.ICodegenTextWriter.DefaultIEnumerableRenderOptions"/> for describing how the items should be separated.
            Default configuration is good for rendering single-line or multiline blocks: 
            - Between the items it ensures a line spacer (a full empty line between the items) if the item has multiple lines, or will just ensure a linebreak if item was a single line
            - If the last item does not end with a line break (ends in a dirty line) it ensures that any further write will go to the next line (force a linebreak only if/when required)
            If you don't want line spacers between the items (useful if you're writing single line items) use the <see cref="P:CodegenCS.RenderEnumerableOptions.LineBreaksWithoutSpacer"/>
            If you just interpolate the IEnumerable{T} without invoking this Render() extension the items will also be rendered (as if Render() was invoked) using the default options.
            If you interpolate an IEnumerable without using the Render() extension it will also follow the default configuration from <see cref="P:CodegenCS.ICodegenTextWriter.DefaultIEnumerableRenderOptions"/>
            </summary>
        </member>
        <member name="M:CodegenCS.IEnumerableExtensions.Render``1(System.Collections.Generic.IEnumerable{``0},CodegenCS.RenderEnumerableOptions)">
            <summary>
            Renders the items by specifying custom rendering options that define how items are separated.
            For presets check the static members of <see cref="T:CodegenCS.RenderEnumerableOptions"/> (e.g. <see cref="P:CodegenCS.RenderEnumerableOptions.LineBreaksWithAutoSpacer"/>, etc)
            </summary>
        </member>
        <member name="M:CodegenCS.IEnumerableExtensions.RenderWithLineBreaks``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Renders items by separating them with line breaks (this is probably what you want). 
            </summary>
            <param name="useLineSpacer">If true (default) it will render an empty line (spacer) between the items</param>
        </member>
        <member name="M:CodegenCS.IEnumerableExtensions.RenderAsSingleLineCSV``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Renders single-line items by joining them with commas. Don't add linebreak after last item.
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.BetweenItemsBehavior">
            <summary>
            What will be written after each enumerable item (except the last one)
            Default value is <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreakBeforeNextWrite"/>. Other common option is <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureFullEmptyLine"/>
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.AfterLastItemBehavior">
            <summary>
            What will be written after the last enumerable item. 
            Default value is <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreakBeforeNextWrite"/>.
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.LineBreaksWithoutSpacer">
            <summary>
            Between the items will ensure that there's a line break (meaning that it will add a linebreak unless the item explicitly wrote a linebreak at the end). (default behavior)
            After the last item it won't write anything but will ensure that next write gets a linebreak (default behavior).
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.LineBreaksWithSpacer">
            <summary>
            Between the items will ensure that there's a line spacer (a full empty line - good for isolating multiline blocks)
            After the last item it won't write anything but will ensure that next write gets a linebreak (default behavior).
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.LineBreaksWithAutoSpacer">
            <summary>
            Between the items will ensure that there's a line spacer (a full empty line) only if the previous item wrote more than a single line, else it will just add ensure a simple linebreak.
            After the last item it won't write anything but will ensure that next write gets a linebreak (default behavior).
            (This is the default option and the recommendation for most cases)
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.SingleLineCSV">
            <summary>
            Between the items will write commas (no linebreaks).
            After the last item won't write anything (no linebreaks or anything).
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.MultiLineCSV">
            <summary>
            Between the items will write a comma and linebreak. 
            After the last item it won't write anything but will ensure that next write gets a linebreak (default behavior).
            </summary>
        </member>
        <member name="P:CodegenCS.RenderEnumerableOptions.SpacedMultiLineCSV">
            <summary>
            Between the items will write a comma and two linebreaks (which means a full empty line between items)
            After the last item it won't write anything but will ensure that next write gets a linebreak (default behavior).
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.WriteLineBreak">
            <summary>
            Writes a line break after writing the item
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreak">
            <summary>
            If the current line is dirty (previous item did not end in a line break) it will write a line break, ensuring that the next line is empty.
            Useful because if the previous item ends with linebreak we don't need to force a new one.
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreakBeforeNextWrite">
            <summary>
            If the current line is dirty (previous item did not end in a line break) it will NOT force a line break, 
            but yet it will ensure that the next write will enforce (render automatically) a line break.
            In other words this signals that the current dirty line can not have any further text appended to the same line.
            This is helpful because when we embed IEnumerables inside Templates we usually already have a linebreak after the IEnumerable, 
            and therefore if <see cref="P:CodegenCS.RenderEnumerableOptions.AfterLastItemBehavior"/> is set to <see cref="F:CodegenCS.ItemsSeparatorBehavior.WriteLineBreak"/> or <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreak"/>
            we would have two linebreaks (meaning an empty line)
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.EnsureFullEmptyLine">
            <summary>
            Ensures that there's at least a full empty line after the item. 
            This is like <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureLineBreak"/> (ensures a line break after a dirty line) and on top of that it writes a full empty line, good for isolation between large blocks.
            E.g. When writing large classes and setting <see cref="P:CodegenCS.RenderEnumerableOptions.BetweenItemsBehavior"/> to <see cref="F:CodegenCS.ItemsSeparatorBehavior.EnsureFullEmptyLine"/> we enforce some isolation between the blocks.
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.EnsureFullEmptyLineAfterMultilineItems">
            <summary>
            Ensures that there's at least a full empty line after the item but only if item wrote more than a single line
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.WriteCustomSeparator">
            <summary>
            Writes a custom separator after the item
            </summary>
        </member>
        <member name="F:CodegenCS.ItemsSeparatorBehavior.None">
            <summary>
            Don't write any separator after the item.
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWith0ModelWrapper`2">
            <inheritdoc cref="T:CodegenCS.ContextedTemplateWith0ModelWrapper`2" />
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWith1ModelWrapper`3">
            <inheritdoc cref="T:CodegenCS.ContextedTemplateWith1ModelWrapper`3" />
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWith2ModelWrapper`4">
            <inheritdoc cref="T:CodegenCS.ContextedTemplateWith2ModelWrapper`4" />
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.__Hidden_IContextedTemplateWithModelWrapper">
            <summary>
            "Hidden" interface just used to make internal calls without using reflection and without having to expose these methods/members in the exposed public interface.
            (casting to concrete class is not possible because of covariance, so using an interface - even without generic - is enough)
            As a hidden interface it should not exposed to user:
            - Should be explicitly-implemented only by the concrete class 
            - Should not be inherited by any other interface that is exposed to user
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper`2">
            <inheritdoc cref="T:CodegenCS.ContextedTemplateWrapper`2" />
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.__Hidden_IContextedTemplateWrapper">
            <summary>
            "Hidden" interface just used to make internal calls without using reflection and without having to expose these methods/members in the exposed public interface.
            (casting to concrete class is not possible because of covariance, so using an interface - even without generic - is enough)
            As a hidden interface it should not exposed to user:
            - Should be explicitly-implemented only by the concrete class 
            - Should not be inherited by any other interface that is exposed to user
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBaseTemplate">
            <summary>
            All Templates implement some interface that inherit from this
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBase0ModelTemplate">
            <summary>
            Templates that do not require any model
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBase1ModelTemplate`1">
            <summary>
            Templates that require a single model
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBase2ModelTemplate`2">
            <summary>
            Templates that require two models
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBaseSinglefileTemplate">
            <summary>
            Templates that output into a single file (either by expecting and writing into a <see cref="T:CodegenCS.ICodegenTextWriter"/> or by returning a string like <see cref="T:CodegenCS.___InternalInterfaces___.IBaseStringTemplate"/> )
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBaseMultifileTemplate">
            <summary>
            Templates that output into a multiple files (and therefore they take a <see cref="T:CodegenCS.ICodegenContext"/> and will decide how to name each output)
            </summary>
        </member>
        <member name="T:CodegenCS.___InternalInterfaces___.IBaseStringTemplate">
            <summary>
            Templates that can be as simple as a single block of text, in this case they just return an interpolated string.
            </summary>
        </member>
        <member name="T:CodegenCS.RawString">
            <summary>
            RawString is just a wrapper around string (with implicit conversion to/from string) which allows us to prioritize methods which use IFormattable (interpolated strings) instead of strings <br />
            If you use interpolated strings (which allow to use a wide range of action delegates) you'll end up using the methods overloads which accept IFormattable. <br />
            If you just pass a regular string it will be converted to RawString. 
            (In other words, if we had overloads taking plain strings then all interpolated strings would be converted to strings and we would break all the magic)
            Based on https://www.damirscorner.com/blog/posts/20180921-FormattableStringAsMethodParameter.html
            </summary>
        </member>
        <member name="M:CodegenCS.RawString.op_Implicit(System.String)~CodegenCS.RawString">
            <summary>
            Implicit conversion
            </summary>
        </member>
        <member name="M:CodegenCS.RawString.op_Implicit(System.FormattableString)~CodegenCS.RawString">
            <summary>
            Implicit conversion
            </summary>
        </member>
        <member name="M:CodegenCS.RawString.op_Implicit(CodegenCS.RawString)~System.String">
            <summary>
            Implicit conversion
            </summary>
        </member>
        <member name="M:CodegenCS.Symbols.IF(System.Boolean)">
            <summary>
            Starts a conditional block. If condition is false, everything written to TextWriter until the matching ELSE or ENDIF will be discarded.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="P:CodegenCS.Symbols.ELSE">
            <summary>
            Starts the ELSE part of a conditional block. If the IF condition is true then everything written to TextWriter from the ELSE until the matching ENDIF will be discarded.
            </summary>
        </member>
        <member name="P:CodegenCS.Symbols.ENDIF">
            <summary>
            Finishes a conditional block. Everything written to TextWritter after this will get back to normal (won't be discarded, even if the IF condition was false).
            </summary>
        </member>
        <member name="M:CodegenCS.Symbols.IIF(System.Boolean,System.FormattableString,System.FormattableString)">
            <summary>
            Immediate IF: Returns one of two objects, depending on the evaluation of an expression.
            </summary>
        </member>
        <member name="T:CodegenCS.ContextedTemplateWith0ModelWrapper`2">
            <summary>
            This is a wrapper around the Template (wraps the Template Type).
            This wrapper is used to embed references to templates right from interpolated strings (or from other contexts) 
            and at the right time (during rendering) this wrapper will resolve the template (build and inject the required dependencies) and render it.
            When <see cref="T:CodegenCS.ICodegenTextWriter"/> "reads" this object as an interpolated string it will resolve and render the template.
            </summary>
            <typeparam name="TTemplate">Type of the Template</typeparam>
            <typeparam name="TContext">Track if the template was invoked from a ICodegenTextWriter or from a ICodegenContext, allowing different extensions for each</typeparam>
        </member>
        <member name="T:CodegenCS.ContextedTemplateWith1ModelWrapper`3">
            <summary>
            This is a wrapper around both the Template (wraps the Template Type) and the model <typeparamref name="TModel"/> required by the template.
            This wrapper is used to embed references to templates (and it's models) right from interpolated strings (or from other contexts) 
            and at the right time (during rendering) this wrapper will resolve the template (build and inject the required dependencies) and render it.
            When <see cref="T:CodegenCS.ICodegenTextWriter"/> "reads" this object as an interpolated string it will resolve and render the template.
            </summary>
            <typeparam name="TTemplate">Type of the Template</typeparam>
            <typeparam name="TContext">Track if the template was invoked from a ICodegenTextWriter or from a ICodegenContext, allowing different extensions for each</typeparam>
            <typeparam name="TModel"></typeparam>
        </member>
        <member name="T:CodegenCS.ContextedTemplateWith2ModelWrapper`4">
            <summary>
            This is a wrapper around both the Template (wraps the Template Type) and the models (<typeparamref name="TModel1"/> and <typeparamref name="TModel2"/>) required by the template.
            This wrapper is used to embed references to templates (and it's models) right from interpolated strings (or from other contexts) 
            and at the right time (during rendering) this wrapper will resolve the template (build and inject the required dependencies) and render it.
            When <see cref="T:CodegenCS.ICodegenTextWriter"/> "reads" this object as an interpolated string it will resolve and render the template.
            </summary>
            <typeparam name="TTemplate">Type of the Template</typeparam>
            <typeparam name="TContext">Track if the template was invoked from a ICodegenTextWriter or from a ICodegenContext, allowing different extensions for each</typeparam>
            <typeparam name="TModel1"></typeparam>
            <typeparam name="TModel2"></typeparam>
        </member>
        <member name="T:CodegenCS.ContextedTemplateWrapper`2">
            <summary>
            This is a wrapper around Templates (wraps the Template Type). 
            This wrapper is used to embed references to templates right from interpolated strings (or from other contexts) 
            and at the right time (during rendering) this wrapper will resolve the template (build and inject the required dependencies) and can be invoked to render it.
            You should use .Render() extensions (<see cref="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.ICodegenContext})" />) /> and (if template requires) provide the model(s)
            </summary>
            <typeparam name="TTemplate">Type of the Template</typeparam>
            <typeparam name="TContext">Track if the template was invoked from a ICodegenTextWriter or from a ICodegenContext, allowing different extensions for each</typeparam>
        </member>
        <member name="T:CodegenCS.IContextedTemplateWrapperExtensions">
            <summary>
            Extensions to IContextedTemplateWrapper that will provide a Render(), Render{TModel}(model) or Render{TModel1, TModel2}(model2, model2) - according to the type of TTemplate
            If the IContextedTemplateWrapper was loaded by <see cref="T:CodegenCS.ICodegenContext"/> or <see cref="T:CodegenCS.ICodegenTextWriter"/> then the Render() will render immediately.
            If the IContextedTemplateWrapper was loaded by <see cref="T:CodegenCS.InlineTemplateLoader"/> (<see cref="M:CodegenCS.Template.Load``1(System.Object[])"/>) then the Render() will 
            just return another wrapper (IContextedTemplateWithModelWrapper) which during the real template rendering will do the real rendering
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.InlineTemplateLoader})">
            <summary>
            Used to render a template that was loaded from inside another template using using string-interpolation and <see cref="M:CodegenCS.Template.Load``1(System.Object[])"/> and that does not require any model.
            Despite the name Render() this actually builds a Lazy-Renderer-Wrapper (an object that will be rendered when <see cref="T:CodegenCS.ICodegenTextWriter"/> is rendering some parent template and finds this embedded).
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``1(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase1ModelTemplate{``0},CodegenCS.InlineTemplateLoader},``0)">
            <summary>
            Used to render a template that was loaded from inside another template using using string-interpolation and <see cref="M:CodegenCS.Template.Load``1(System.Object[])"/> and that does require one model of type <typeparamref name="TModel"/>
            Despite the name Render() this actually builds a Lazy-Renderer-Wrapper (an object that will be rendered when <see cref="T:CodegenCS.ICodegenTextWriter"/> is rendering some parent template and finds this embedded).
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``2(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase2ModelTemplate{``0,``1},CodegenCS.InlineTemplateLoader},``0,``1)">
            <summary>
            Used to render a template that was loaded from inside another template using using string-interpolation and <see cref="M:CodegenCS.Template.Load``1(System.Object[])"/> and that does require two model (type <typeparamref name="TModel1"/> and <typeparamref name="TModel2"/>)
            Despite the name Render() this actually builds a Lazy-Renderer-Wrapper (an object that will be rendered when <see cref="T:CodegenCS.ICodegenTextWriter"/> is rendering some parent template and finds this embedded).
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.ICodegenTextWriter})">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``1(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase1ModelTemplate{``0},CodegenCS.ICodegenTextWriter},``0)">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``2(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase2ModelTemplate{``0,``1},CodegenCS.ICodegenTextWriter},``0,``1)">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase0ModelTemplate,CodegenCS.ICodegenContext})">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``1(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase1ModelTemplate{``0},CodegenCS.ICodegenContext},``0)">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="M:CodegenCS.IContextedTemplateWrapperExtensions.Render``2(CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper{CodegenCS.___InternalInterfaces___.IBase2ModelTemplate{``0,``1},CodegenCS.ICodegenContext},``0,``1)">
            <summary>
            Renders the template
            </summary>
        </member>
        <member name="T:CodegenCS.InlineTemplateLoader">
            <summary>
            This is used as context (TContext) of <see cref="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper`2"/>, 
            allowing <see cref="T:CodegenCS.___InternalInterfaces___.IContextedTemplateWrapper`2"/> to have extensions according to the context (<see cref="T:CodegenCS.InlineTemplateLoader"/>, <see cref="T:CodegenCS.ICodegenContext"/> or <see cref="T:CodegenCS.ICodegenTextWriter"/>).
            </summary>
        </member>
        <member name="T:CodegenCS.Template">
            <summary>
            Inside the interpolated strings of any template we can just call Template.Load{TTemplate}().Render(model).
            Requires "using CodegenCS;"
            </summary>
        </member>
        <member name="M:CodegenCS.Template.Load``1(System.Object[])">
            <summary>
            Loads a template by the Type (class name). Allow to pass dependencies required by the template.
            </summary>
            <typeparam name="TTemplate">Template type</typeparam>
            <param name="dependencies">Optional dependencies that will be injected if the template constructor requires it</param>
        </member>
        <member name="T:CodegenCS.ICodegenTemplate">
            <summary>
            Templates that output into a single file and do not require any model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenTemplate`1">
            <summary>
            Templates that output into a single file and require a single model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenTemplate`2">
            <summary>
            Templates that output into a single file and require two models
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenMultifileTemplate">
            <summary>
            Templates that output into multiple files and do not require any model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenMultifileTemplate`1">
            <summary>
            Templates that output into multiple files and require a single model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenMultifileTemplate`2">
            <summary>
            Templates that output into multiple files and require two models
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenStringTemplate">
            <summary>
            Templates that return a single block of text and do not require any model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenStringTemplate`1">
            <summary>
            Templates that return a single block of text and require a single model
            </summary>
        </member>
        <member name="T:CodegenCS.ICodegenStringTemplate`2">
            <summary>
            Templates that return a single block of text and require two models
            </summary>
        </member>
        <member name="T:CodegenCS.Utils.CommandLineArgsParser">
            <summary>
            Parse command-line arguments. Based on https://www.codeproject.com/Articles/3111/C-NET-Command-Line-Arguments-Parser
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.CommandLineArgsParser.#ctor(System.String[])">
            <summary>
            Parse command-line arguments.
            </summary>
            <returns>Dictionary (case insensitive) of arguments. Orphaned arguments (those that don't have "=value") will return "true"</returns>
        </member>
        <member name="P:CodegenCS.Utils.CommandLineArgsParser.Item(System.String)">
            <summary>
            Retrieve a parameter value if it exists. Null if not found. "true" (lowecase) if "/parameter" was provided but without passing a value.
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.CommandLineArgsParser.ContainsKey(System.String)">
            <summary>
            Determines whether the parameters provided the specified key
            </summary>
        </member>
    </members>
</doc>
